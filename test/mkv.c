/** avpack: .mkv tester
2021, Simon Zolin
*/

#include <avpack/mkv-read.h>
#include <test/test.h>

// 1msec (44 frames), pcm_s16le, 44100 Hz, stereo, meta='artist=A;title=T'
const ffbyte mkv_sample[] = {
"\x1a\x45\xdf\xa3\xa3\x42\x86\x81\x01\x42\xf7\x81\x01\x42\xf2\x81"
"\x04\x42\xf3\x81\x08\x42\x82\x88\x6d\x61\x74\x72\x6f\x73\x6b\x61"
"\x42\x87\x81\x04\x42\x85\x81\x02\x18\x53\x80\x67\x01\x00\x00\x00"
"\x00\x00\x02\xe7\x11\x4d\x9b\x74\xc0\xbf\x84\x8a\x69\x1f\xb7\x4d"
"\xbb\x8b\x53\xab\x84\x15\x49\xa9\x66\x53\xac\x81\xa1\x4d\xbb\x8b"
"\x53\xab\x84\x16\x54\xae\x6b\x53\xac\x81\xf5\x4d\xbb\x8c\x53\xab"
"\x84\x12\x54\xc3\x67\x53\xac\x82\x01\x46\x4d\xbb\x8c\x53\xab\x84"
"\x1c\x53\xbb\x6b\x53\xac\x82\x02\xcb\xec\x01\x00\x00\x00\x00\x00"
"\x00\x53\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x15\x49\xa9\x66\xcf\xbf\x84\xd2\xd4\x74\x18"
"\x2a\xd7\xb1\x83\x0f\x42\x40\x7b\xa9\x81\x54\x4d\x80\x8d\x4c\x61"
"\x76\x66\x35\x38\x2e\x34\x35\x2e\x31\x30\x30\x57\x41\x8d\x4c\x61"
"\x76\x66\x35\x38\x2e\x34\x35\x2e\x31\x30\x30\x73\xa4\x90\xf7\xf3"
"\xfd\x5e\xf0\xeb\x1f\x7d\x04\x4c\xb9\xac\xfd\xfe\xac\xe8\x44\x89"
"\x88\x3f\xf0\x00\x00\x00\x00\x00\x00\x16\x54\xae\x6b\xcc\xbf\x84"
"\x17\xbe\xe6\x2e\xae\x01\x00\x00\x00\x00\x00\x00\x3d\xd7\x81\x01"
"\x73\xc5\x88\x58\xb5\xc0\xe4\x4e\xb5\x09\x66\x9c\x81\x00\x22\xb5"
"\x9c\x83\x75\x6e\x64\x86\x8d\x41\x5f\x50\x43\x4d\x2f\x49\x4e\x54"
"\x2f\x4c\x49\x54\x83\x81\x02\xe1\x91\x9f\x81\x02\xb5\x88\x40\xe5"
"\x88\x80\x00\x00\x00\x00\x62\x64\x81\x10\x12\x54\xc3\x67\x40\xb9"
"\xbf\x84\xac\x18\x2c\xa0\x73\x73\x01\x00\x00\x00\x00\x00\x00\x3e"
"\x63\xc0\x80\x67\xc8\x01\x00\x00\x00\x00\x00\x00\x0d\x45\xa3\x86"
"\x41\x52\x54\x49\x53\x54\x44\x87\x81\x41\x67\xc8\x01\x00\x00\x00"
"\x00\x00\x00\x1a\x45\xa3\x87\x45\x4e\x43\x4f\x44\x45\x52\x44\x87"
"\x8d\x4c\x61\x76\x66\x35\x38\x2e\x34\x35\x2e\x31\x30\x30\x73\x73"
"\x01\x00\x00\x00\x00\x00\x00\x61\x63\xc0\x8b\x63\xc5\x88\x58\xb5"
"\xc0\xe4\x4e\xb5\x09\x66\x67\xc8\x01\x00\x00\x00\x00\x00\x00\x24"
"\x45\xa3\x87\x45\x4e\x43\x4f\x44\x45\x52\x44\x87\x97\x4c\x61\x76"
"\x63\x35\x38\x2e\x39\x31\x2e\x31\x30\x30\x20\x70\x63\x6d\x5f\x73"
"\x31\x36\x6c\x65\x67\xc8\xa2\x45\xa3\x88\x44\x55\x52\x41\x54\x49"
"\x4f\x4e\x44\x87\x94\x30\x30\x3a\x30\x30\x3a\x30\x30\x2e\x30\x30"
"\x31\x30\x30\x30\x30\x30\x30\x00\x00\x1f\x43\xb6\x75\x40\xc0\xbf"
"\x84\x4d\x81\x59\xef\xe7\x81\x00\xa3\x40\xb4\x81\x00\x00\x80\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1c"
"\x53\xbb\x6b\x97\xbf\x84\x11\x21\xee\x48\xbb\x8f\xb3\x81\x00\xb7"
"\x8a\xf7\x81\x01\xf1\x82\x02\x05\xf0\x81\x09"
};


static void mkvr_log(void *udata, ffstr msg)
{
	(void)udata;
	printf("%.*s\n", (int)msg.len, msg.ptr);
}

void test_mkv_read(ffstr data)
{
	int r;
	ffstr in, out;
	mkvread m = {};
	m.log = mkvr_log;
	mkvread_open(&m, 0);
	ffstr_set(&in, data.ptr, 1);
	ffuint off = 1;
	ffuint track_total = 1;
	ffuint track_audio = 0;
	ffuint track_audio_id = 1;
	ffuint itag = 0;

	for (;;) {
		r = mkvread_process(&m, &in, &out);
		// printf("mkvread_process: %d\n", r);
		switch (r) {
		case MKVREAD_HEADER: {
			const struct mkvread_audio_info *ti = mkvread_track_info(&m, track_audio);
			x(NULL == mkvread_track_info(&m, track_total));
			xieq(MKV_TRK_AUDIO, ti->type);
			xieq(MKV_A_PCM, ti->codec);
			xieq(16, ti->bits);
			xieq(2, ti->channels);
			xieq(44100, ti->sample_rate);
			x(ti->codec_conf.len == 0);
			goto next;
		}

		case MKVREAD_TAG: {
			ffstr val;
			ffstr name = mkvread_tag(&m, &val);
			printf("mkvread_tag: %.*s = %.*s\n"
				, (int)name.len, name.ptr
				, (int)val.len, val.ptr);
			switch (itag++) {
			case 0:
				xseq(&name, "title");
				xseq(&val, "T");
				break;
			case 1:
				xseq(&name, "ARTIST");
				xseq(&val, "A");
				break;
			}
			break;
		}

		case MKVREAD_SEEK:
			off = mkvread_offset(&m);
			// fallthrough
		case MKVREAD_MORE:
			ffstr_set(&in, data.ptr + off, 1);
			off++;
			break;

		default:
			printf("mkvread_process: %s\n", mkvread_error(&m));
			x(0);
		}
	}

next:
	for (;;) {
		r = mkvread_process(&m, &in, &out);
		// printf("mkvread_process: %d\n", r);
		switch (r) {
		case MKVREAD_DATA:
			if (mkvread_block_trackid(&m) != track_audio_id)
				break;
			xieq(44*2*2, out.len);
			// xseq(&out, "aacframe1");
			printf("frame:%u curpos=%u\n", (int)out.len, (int)mkvread_curpos(&m));
			break;
		case MKVREAD_DONE:
			goto end;

		case MKVREAD_SEEK:
			off = mkvread_offset(&m);
			// fallthrough
		case MKVREAD_MORE:
			ffstr_set(&in, data.ptr + off, 1);
			off++;
			break;

		default:
			x(0);
		}
	}

	//mkvread_seek

end:
	mkvread_close(&m);
}

void test_mkv()
{
	ffstr data = {};
	ffstr_set(&data, mkv_sample, sizeof(mkv_sample)-1);

#if 0
	x(0 == file_readall("/tmp/1.mkv", &data));
#endif

	test_mkv_read(data);
}
