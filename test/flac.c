/** avpack: .flac tester
2021, Simon Zolin
*/

#define FLACREAD_NOCRC
#include <avpack/flac-ogg-read.h>
#include <avpack/flac-read.h>
#include <avpack/flac-write.h>
#include <test/test.h>
#include <ffbase/mem-print.h>
extern int Verbose;

const char flac_frame[] = {"\xff\xf8\xc9\x18\x00\xc2\x00\x00\x00\x00\x00\x00\xb8\xee"};

// 11 frames, 4k samples/frame
const char flac_sample[] = {
	"\x66\x4c\x61\x43\x00\x00\x00\x22\x10\x00\x10\x00\x00\x00\x0e\x00"
	"\x00\x10\x0a\xc4\x42\xf0\x00\x00\xac\x44\xd2\xb1\x20\x19\x90\x19"
	"\xb6\x39\xd5\xa7\xe2\xb3\x46\x3e\x9c\x97\x04\x00\x00\x28\x20\x00"
	"\x00\x00\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x6c\x69\x62\x46"
	"\x4c\x41\x43\x20\x31\x2e\x33\x2e\x32\x20\x32\x30\x31\x37\x30\x31"
	"\x30\x31\x00\x00\x00\x00\x81\x00\x03\xc0\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xf8\xc9\x18\x00\xc2"
	"\x00\x00\x00\x00\x00\x00\xb8\xee\xff\xf8\xc9\x18\x01\xc5\x00\x00"
	"\x00\x00\x00\x00\x2f\x9b\xff\xf8\xc9\x18\x02\xcc\x00\x00\x00\x00"
	"\x00\x00\x16\x01\xff\xf8\xc9\x18\x03\xcb\x00\x00\x00\x00\x00\x00"
	"\x81\x74\xff\xf8\xc9\x18\x04\xde\x00\x00\x00\x00\x00\x00\x65\x35"
	"\xff\xf8\xc9\x18\x05\xd9\x00\x00\x00\x00\x00\x00\xf2\x40\xff\xf8"
	"\xc9\x18\x06\xd0\x00\x00\x00\x00\x00\x00\xcb\xda\xff\xf8\xc9\x18"
	"\x07\xd7\x00\x00\x00\x00\x00\x00\x5c\xaf\xff\xf8\xc9\x18\x08\xfa"
	"\x00\x00\x00\x00\x00\x00\x83\x5d\xff\xf8\xc9\x18\x09\xfd\x00\x00"
	"\x00\x00\x00\x00\x14\x28\xff\xf8\x79\x18\x0a\x0c\x43\xb3\x00\x00"
	"\x00\x00\x00\x00\xe2\xc9"
};

unsigned char flac_crc8(const char *data, unsigned int len)
{
	(void)data;  (void)len;
	return 0;
}

struct tag {
	ffuint name;
	const char *val;
};
static const struct tag tags[] = {
	{ MMTAG_VENDOR, "vendor" },
	{ MMTAG_ALBUM, "album" },
	{ MMTAG_ARTIST, "artist" },
	{ MMTAG_DATE, "date" },
	{ MMTAG_TITLE, "title" },
	{ MMTAG_TRACKNO, "01" },
	{ MMTAG_TRACKTOTAL, "09" },
};

ffvec test_flac_write()
{
	ffvec v = {};
	flacwrite f = {};
	int r;
	ffuint off = 0;
	ffstr in, out;
	struct flac_info info = {};
	info.bits = 16;
	info.sample_rate = 44100;
	info.channels = 2;
	flacwrite_create(&f, &info, 0);

	const struct tag *tag;
	FFARRAY_FOREACH(tags, tag) {
		ffstr val = FFSTR_INITZ(tag->val);
		x(0 == flacwrite_addtag(&f, tag->name, val));
	}

	ffstr_set(&in, flac_frame, sizeof(flac_frame)-1);

	for (;;) {
		r = flacwrite_process(&f, &in, 123, &out);
		// xlog("flacwrite_process: %d", r);
		switch (r) {
		case FLACWRITE_DATA:
			ffvec_grow(&v, out.len, 1);
			ffmem_copy(v.ptr + off, out.ptr, out.len);
			off += out.len;
			v.len = ffmax(v.len, off);
			break;
		case FLACWRITE_SEEK:
			off = flacwrite_offset(&f);
			break;
		case FLACWRITE_DONE:
			x(in.len == 0);
			goto end;
		case FLACWRITE_MORE:
			flacwrite_finish(&f, &info);
			break;
		default:
			x(0);
		}
	}

end:
	flacwrite_close(&f);
	return v;
}

static void flacr_log(void *udata, const char *fmt, va_list va)
{
	(void)udata;
	xlogv(fmt, va);
}

void test_flac_read(ffstr data, int partial, int seek)
{
	int r;
	ffstr in = {}, out;
	flacread f = {};
	f.log = flacr_log;
	flacread_open(&f, data.len);
	ffuint off = 0;
	int frno = 0;

	for (int i = data.len*2;;  i--) {
		x(i >= 0);

		r = flacread_process(&f, &in, &out);
		// xlog("flacread_process: %d", r);
		switch (r) {

		case FLACREAD_TAG: {
			ffstr name, val;
			ffuint t = flacread_tag(&f, &name, &val);
			// int k = 0;
			const struct tag *tag;
			FFARRAY_FOREACH(tags, tag) {
				if (tag->name == t) {
					// xseq(&val, tag->val);
					// k = 1;
					break;
				}
			}
			xlog("flacread_tag: (%u) %S = %S", (int)t, &name , &val);
			// x(k == 1);
			break;
		}

		case FLACREAD_HEADER: {
			const struct flac_info *info = flacread_info(&f);
			xieq(16, info->bits);
			xieq(44100, info->sample_rate);
			xieq(2, info->channels);
			x(info->bitrate != 0);
			x(info->total_samples != 0);

			if (seek != 0)
				flacread_seek(&f, seek);
			break;
		}

		case FLACREAD_DATA:
			frno++;
			// xlog("frame#%d:%u [%u(%u)]", frno, (int)out.len
			// 	, flacread_cursample(&f), flacread_samples(&f));
			break;

		case FLACREAD_SEEK:
			off = flacread_offset(&f);
			// fallthrough
		case FLACREAD_MORE:
			if (off == data.len) {
				flacread_finish(&f);
				break;
			}
			ffstr_setstr(&in, &data);
			ffstr_shift(&in, off);
			if (partial)
				ffstr_set(&in, data.ptr + off, ffmin(partial, data.len - off));
			off += in.len;
			break;

		case FLACREAD_HEADER_FIN:
			break;

		case FLACREAD_DONE:
			goto end;

		default:
			xlog("error: flacread_process: %s", flacread_error(&f));
			x(0);
		}
	}

end:
	x(frno != 0);
	flacread_close(&f);
}

void test_flac_seek(ffstr data, ffuint delta_msec, int partial)
{
	int r;
	ffstr in = {}, out;
	flacread f = {};
	f.log = flacr_log;
	flacread_open(&f, data.len);
	ffuint seek = 0;
	ffuint off = 0;
	ffuint reqs = 0, fileseek = 0;
	const struct flac_info *info;

	for (int i = data.len;;  i--) {
		x(i >= 0);

		r = flacread_process(&f, &in, &out);
		// xlog("flacread_process: %d", r);
		switch (r) {
		case FLACREAD_HEADER:
			info = flacread_info(&f);
			break;
		case FLACREAD_TAG:
			break;
		case FLACREAD_HEADER_FIN:
			break;
		case FLACREAD_DATA:
			if (seek != 0) {
				x(flacread_cursample(&f) <= seek);
				x(seek < flacread_cursample(&f) + f.frame.samples);
			}

			seek += delta_msec * info->sample_rate / 1000;
			if (seek > info->total_samples)
				goto end;
			reqs++;
			flacread_seek(&f, seek);
			xlog("flacread: seeking to: %u", seek);
			break;

		case FLACREAD_SEEK:
			fileseek++;
			off = flacread_offset(&f);
			// fallthrough

		case FLACREAD_MORE:
			if (off == data.len)
				goto end;
			ffstr_setstr(&in, &data);
			ffstr_shift(&in, off);
			if (partial)
				ffstr_set(&in, data.ptr + off, ffmin(partial, data.len - off));
			off += in.len;
			break;

		case FLACREAD_DONE:
			goto end;

		default:
			xlog("error: flacread_process: %s", flacread_error(&f));
			x(0);
		}
	}

end:
	xlog("flacread: seek-reqs:%u  avg-file-seek-reqs:%u"
		, reqs, fileseek/reqs);
	flacread_close(&f);
}

void test_flac()
{
	ffvec buf = {};
	buf = test_flac_write();

	if (Verbose) {
		ffstr s = ffmem_print(buf.ptr, buf.len, FFMEM_PRINT_ZEROSPACE);
		xlog("%S", &s);
		ffstr_free(&s);
	}

	ffstr data = FFSTR_INITSTR(&buf);
	test_flac_read(data, 0, 0);

	ffstr_set(&data, flac_sample, sizeof(flac_sample)-1);
	test_flac_read(data, 0, 0);
	test_flac_read(data, 3, 0);
	test_flac_read(data, 0, 6000);
	test_flac_read(data, 0, 40961);

#if 0
	ffstr_null(&data);
	file_readall("/tmp/1.flac", &data);
	test_flac_seek(data, 900, 64*1024);
	ffstr_free(&data);
#endif

	ffvec_free(&buf);
}
